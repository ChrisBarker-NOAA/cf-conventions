==  NetCDF Files and Components 

The components of a netCDF file are described in section 2 of the NUG <<NUG>>.
In this section we describe conventions associated with filenames and the basic components of a netCDF file.
We also introduce new attributes for describing the contents of a file.

=== Filename

NetCDF files should have the file name extension "**`.nc`**".

=== Data Types

// TODO: Check, should this be a bullet list?
Data variables must be one of the following data types: **`string`**, **`char`**, **`byte`**, **`unsigned byte`**, **`short`**, **`unsigned short`**, **`int`**, **`unsigned int`**, **`int64`**, **`unsigned int64`**, **`float`** or **`real`**, and **`double`** (which are all the link:$$https://docs.unidata.ucar.edu/nug/current/md_types.html$$[netCDF external data types] supported by netCDF-4).
The **`string`** type is only available in files using the netCDF version 4 (netCDF-4) format.
The **`char`** and **`string`** types are not intended for numeric data.
One byte numeric data should be stored using the **`byte`** or **`unsigned byte`** data types.
It is possible to treat the **`byte`** and **`short`** types as unsigned by using the NUG convention of indicating the unsigned range using the **`valid_min`**, **`valid_max`**, or **`valid_range`** attributes.
In many situations, any integer type may be used.
When the phrase "integer type" is used in this document, it should be understood to mean **`byte`**, **`unsigned byte`**, **`short`**, **`unsigned short`**, **`int`**, **`unsigned int`**, **`int64`**, or **`unsigned int64`**.

Strings in variables may be represented one of two ways - as atomic strings or as character arrays.
An n-dimensional array of strings may be implemented as a variable of type **`string`** with _n_ dimensions, or as a variable of type **`char`** with _n_+1 dimensions, where the most rapidly varying dimension (the last dimension in CDL order) is large enough to contain the longest string in the variable.
For example, a character array variable of strings containing the names of the months would be dimensioned (12,9) in order to accommodate "September", the month with the longest name.
The other strings, such as "May", should be padded with trailing NULL or space characters so that every array element is filled.
If the atomic string option is chosen, each element of the variable can be assigned a string with a different length.
The CDL example below shows one variable of each type.

[[char-and-string-variables-ex]]
[caption="Example 2.1. "]
.String Variable Representations
====
----
dimensions:
  strings = 30 ;
  strlen = 10 ;
variables:
  char char_variable(strings,strlen) ;
    char_variable:long_name = "strings of type char" ;
  string str_variable(strings) ;
    str_variable:long_name = "strings of type string" ;
----
====

The examples in this document that use string-valued variables alternate between these two forms.

=== Naming Conventions

It is recommended that variable, dimension, attribute and group names begin with a letter and be composed of letters, digits, and underscores.
By the word _letters_ we mean the standard ASCII letters uppercase `A` to `Z` and lowercase `a` to `z`.
By the word _digits_ we mean the standard ASCII digits `0` to `9`, and similarly _underscores_ means the standard ASCII underscore `_`.
Note that this is in conformance with the COARDS conventions, but is more restrictive than the netCDF interface which allows almost all Unicode characters encoded as multibyte UTF-8 characters (link:$$https://docs.unidata.ucar.edu/nug/current/file_format_specifications.html$$[NUG Appendix B]).
The netCDF interface also allows leading underscores in names, but the NUG states that this is reserved for system use.
ASCII period (.) and ASCII hyphen (-) are also allowed in attribute names only.

Case is significant in netCDF names, but it is recommended that names should not be distinguished purely by case, i.e., if case is disregarded, no two names should be the same.
It is also recommended that names should be obviously meaningful, if possible, as this renders the file more effectively self-describing.

This convention does not standardize any variable or dimension names.
Attribute names and their contents, where standardized, are given in English in this document and should appear in English in conforming netCDF files for the sake of portability.
Languages other than English are permitted for variables, dimensions, and non-standardized attributes.
The content of some standardized attributes are string values that are not standardized, and thus are not required to be in English.
For example, a description of what a variable represents may be given in a non-English language using the **`long_name`** attribute (see <<long-name>>) whose contents are not standardized, but a description given by the **`standard_name`** attribute (see <<standard-name>>) must be taken from the standard name table which is in English.

[[dimensions]]
=== Dimensions

A variable may have any number of dimensions, including zero, and the dimensions must all have different names.
__COARDS strongly recommends limiting the number of dimensions to four, but we wish to allow greater flexibility__.
The dimensions of the variable define the axes of the quantity it contains.
Dimensions other than those of space and time may be included.
Several examples can be found in this document.
Under certain circumstances, one may need more than one dimension in a particular quantity.
For instance, a variable containing a two-dimensional probability density function might correlate the temperature at two different vertical levels, and hence would have temperature on both axes.

If any or all of the dimensions of a variable have the interpretations of "date or time" (**`T`**), "height or depth" (**`Z`**), "latitude" (**`Y`**), or "longitude" (**`X`**) then we recommend, but do not require (see <<coards-relationship>>), those dimensions to appear in the relative order **`T`**, then **`Z`**, then **`Y`**, then **`X`** in the CDL definition corresponding to the file.
All other dimensions should, whenever possible, be placed to the left of the spatiotemporal dimensions.

Dimensions may be of any size, including unity.
When a single value of some coordinate applies to all the values in a variable, the recommended means of attaching this information to the variable is by use of a dimension of size unity with a one-element coordinate variable.
It is also acceptable to use a scalar coordinate variable which eliminates the need for an associated size one dimension in the data variable.
The advantage of using either a coordinate variable or an auxiliary coordinate variable is that all its attributes can be used to describe the single-valued quantity, including boundaries.
For example, a variable containing data for temperature at 1.5 m above the ground has a single-valued coordinate supplying a height of 1.5 m, and a time-mean quantity has a single-valued time coordinate with an associated boundary variable to record the start and end of the averaging period.

[[variables]]
=== Variables

This convention does not standardize variable names.

NetCDF variables that contain coordinate data are referred to as __coordinate variables__, __auxiliary coordinate variables__, __scalar coordinate variables__, or __multidimensional coordinate variables__.

[[missing-data, Section 2.5.1, "Missing data, valid and actual range of data"]]
==== Missing data, valid and actual range of data

The NUG conventions
(link:$$https://www.unidata.ucar.edu/software/netcdf/docs/attribute_conventions.html$$[NUG Appendix A, Attribute Conventions])
provide the **`_FillValue`**, **`missing_value`**, **`valid_min`**, **`valid_max`**, and **`valid_range`** attributes to indicate missing data.
Missing data is allowed in data variables and auxiliary coordinate variables.
Generic applications should treat the data as missing where any auxiliary coordinate variables have missing values; special-purpose applications might be able to make use of the data.
Missing data is not allowed in coordinate variables.

The NUG conventions for missing data changed significantly between version 2.3 and version 2.4.
Since version 2.4 the NUG defines missing data as all values outside of the **`valid_range`**, and specifies how the **`valid_range`** should be defined from the **`_FillValue`** (which has library specified default values) if it hasn't been explicitly specified.
If only one missing value is needed for a variable then we recommend  that this value be specified using the **`_FillValue`** attribute.
Doing this guarantees that the missing value will be recognized by generic applications that follow either the before or after version 2.4 conventions.

The scalar attribute with the name **`_FillValue`** and of the same type as its variable is recognized by the netCDF library as the value used to pre-fill disk space allocated to the variable.
This value is considered to be a special value that indicates undefined or missing data, and is returned when reading values that were not written.
The **`_FillValue`** should be outside the range specified by **`valid_range`** (if used) for a variable.
The netCDF library defines a default fill value for each data type (See the "Note on fill values" in link:$$https://www.unidata.ucar.edu/software/netcdf/docs/file_format_specifications.html#classic_format_spec$$[NUG Appendix B, File Format Specifications]).

The missing values of a variable with **`scale_factor`** and/or **`add_offset`** attributes (see <<packed-data>>) are interpreted relative to the variable's external values (a.k.a. the packed values, the raw values, the values stored in the netCDF file), not the values that result after the scale and offset are applied.
Applications that process variables that have attributes to indicate both a transformation (via a scale and/or offset) and missing values should first check that a data value is valid, and then apply the transformation.
Note that values that are identified as missing should not be transformed.
Since the missing value is outside the valid range it is possible that applying a transformation to it could result in an invalid operation.
For example, the default **`_FillValue`** is very close to the maximum representable value of IEEE single precision floats, and multiplying it by 100 produces an "Infinity" (using single precision arithmetic).

This convention defines a two-element vector attribute **`actual_range`** for variables containing numeric data.
If the variable is packed using the **`scale_factor`** and **`add_offset`** attributes (see <<packed-data>>), the elements of the **`actual_range`** should have the type intended for the unpacked data.
The elements of **`actual_range`** must be exactly equal to the minimum and the maximum data values which occur in the variable (when unpacked if packing is used), and both must be within the **`valid_range`** if specified.
If the data is all missing or invalid, the **`actual_range`** attribute cannot be used.

=== Attributes

This standard describes many attributes (some mandatory, others optional), but a file may also contain non-standard attributes.
Such attributes do not represent a violation of this standard.
Application programs should ignore attributes that they do not recognise or which are irrelevant for their purposes.
Conventional attribute names should be used wherever applicable.
Non-standard names should be as meaningful as possible.
Before introducing an attribute, consideration should be given to whether the information would be better represented as a variable.
In general, if a proposed attribute requires ancillary data to describe it, is multidimensional, requires any of the defined netCDF dimensions to index its values, or requires a significant amount of storage, a variable should be used instead.
When this standard defines string attributes that may take various prescribed values, the possible values are generally given in lower case.
However, applications programs should not be sensitive to case in these attributes.
Several string attributes are defined by this standard to contain "blank-separated lists".
Consecutive words in such a list are separated by one or more adjacent spaces.
The list may begin and end with any number of spaces.
See <<attribute-appendix>> for a list of attributes described by this standard.

[[identification-of-conventions]]
==== Identification of Conventions

Files that follow this version of the CF Conventions must indicate this by setting the NUG defined global attribute **`Conventions`** to a string value that contains "**`CF-{current-version-as-attribute}`**".
The Conventions version number contained in that string can be used to find the web based versions of this document are from the link:$$https://cfconventions.org/$$[netCDF Conventions web page].
Subsequent versions of the CF Conventions will not make invalid a compliant usage of this or earlier versions of the CF terms and forms.

It is possible for a netCDF file to adhere to more than one set of conventions, even when there is no inheritance relationship among the conventions.
In this case, the value of the Conventions attribute may be a single text string containing a list of the convention names separated by blank space (recommended) or commas (if a convention name contains blanks).
This is the Unidata recommended syntax from NetCDF Users Guide, Appendix A.
If the string contains any commas, it is assumed to be a comma-separated list.

When CF is listed with other conventions, this asserts the same full compliance with CF requirements and interpretations as if CF was the sole convention.
It is the responsibility of the data-writer to ensure that all common metadata is used with consistent meaning between conventions.

The UGRID conventions, which are fully incorporated into the CF conventions, do not need to be included in the **`Conventions`** attribute.  

[[description-of-file-contents, Section 2.6.2, "Description of file contents"]]
==== Description of file contents

The following attributes are intended to provide information about where the data came from and what has been done to it.
This information is mainly for the benefit of human readers.
The attribute values are all character strings.
For readability in ncdump outputs it is recommended to embed newline characters into long strings to break them into lines.
For backwards compatibility with COARDS none of these global attributes is required.

The NUG defines **`title`** and **`history`** to be global attributes.
We wish to allow the newly defined attributes, i.e., **`institution`**, **`source`**, **`references`**, and **`comment`**, to be either global or assigned to individual variables.
When an attribute appears both globally and as a variable attribute, the variable's version has precedence.

**`title`**:: A succinct description of what is in the dataset.

**`institution`**:: Specifies where the original data was produced.

**`source`**:: The method of production of the original data.
If it was model-generated, **`source`** should name the model and its version, as specifically as could be useful.
If it is observational, **`source`** should characterize it (e.g., "**`surface observation`**" or "**`radiosonde`**").

**`history`**:: Provides an audit trail for modifications to the original data.
Well-behaved generic netCDF filters will automatically append their name and the parameters with which they were invoked to the global history attribute of an input netCDF file.
We recommend that each line begin with a timestamp indicating the date and time of day that the program was executed.

**`references`**:: Published or web-based references that describe the data or methods used to produce it.

**`comment`**:: Miscellaneous information about the data or methods used to produce it.

[[external-variables, Section 2.6.3, "External variables"]]
==== External Variables
The global **`external_variables`** attribute is a blank-separated list of the names of variables which are named by attributes in the file but which are not present in the file.
These variables are to be found in other files (called "external files") but CF does not provide conventions for identifying the files concerned.
The only attribute for which CF standardises the use of external variables is **`cell_measures`**.

[[groups, Section 2.7, "Groups"]]
=== Groups

Groups provide a powerful mechanism to structure data hierarchically.
This convention does not standardize group names.
It may be of benefit to name groups in such a way that human readers can interpret them.
However, files that conform to this standard shall not require software to interpret or decode information from group names.
References to out-of-group variable and dimensions shall be found by applying the scoping rules outlined below.

==== Scope

The scoping mechanism is in keeping with the following principle:

[quote, 'https://www.unidata.ucar.edu/software/netcdf/docs/groups.html[The NetCDF Data Model: Groups]']
"Dimensions are scoped such that they are visible to all child groups.
For example, you can define a dimension in the root group, and use its dimension id when defining a variable in a sub-group."

Any variable or dimension can be referred to, as long as it can be found with one of the following search strategies:

* Search by absolute path
* Search by relative path
* Search by proximity

These strategies are explained in detail in the following sections.

If any dimension of an out-of-group variable has the same name as a dimension of the referring variable, the two must be the same dimension (i.e. they must have the same netCDF dimension ID).

===== Search by absolute path

A variable or dimension specified with an absolute path (i.e., with a leading slash "/") is at the indicated location relative to the root group, as in a UNIX-style file convention.
For example, a `coordinates` attribute of `/g1/lat` refers to the `lat` variable in group `/g1`.

===== Search by relative path

As in a UNIX-style file convention, a variable or dimension specified with a relative path (i.e., containing a slash but not with a leading slash, e.g. `child/lat`) is at the location obtained by affixing the relative path to the absolute path of the referring attribute.
For example, a `coordinates` attribute of `g1/lat` refers to the `lat` variable in subgroup `g1` of the current (referring) group.
Upward path traversals from the current group are indicated with the UNIX convention.
For example, `../g1/lat` refers to the `lat` variable in the sibling group `g1` of the current (referring) group.

===== Search by proximity

A variable or dimension specified with no path (for example, `lat`) refers to the variable or dimension of that name, if there is one, in the referring group.
If not, the ancestors of the referring group are searched for it, starting from the direct ancestor and proceeding toward the root group, until it is found.

A special case exists for coordinate variables.
Because coordinate variables must share dimensions with the variables that reference them, the ancestor search is executed only until the local apex group is reached.
For coordinate variables that are not found in the referring group or its ancestors, a further strategy is provided, called lateral search.
The lateral search proceeds downwards from the local apex group width-wise through each level of groups until the sought coordinate is found.
The lateral search algorithm may only be used for NUG coordinate variables; it shall not be used for auxiliary coordinate variables.

[NOTE]
====
This use of the lateral search strategy to find them is discouraged.
They are allowed mainly for backwards-compatibility with existing datasets, and may be deprecated in future versions of the standard.
====

==== Application of attributes

The following attributes are optional for non-root groups.
They are allowed in order to provide additional provenance and description of the subsidiary data.
They do not override attributes from parent groups.

* `title`
* `history`

If these attributes are present, they may be applied additively to the parent attributes of the same name.
If a file containing groups is modified, the user or application need only update these attributes in the root group, rather than traversing all groups and updating all attributes that are found with the same name.
In the case of conflicts, the root group attribute takes precedence over per-group instances of these attributes.

The following attributes may only be used in the root group and shall not be duplicated or overridden in child groups:

* `Conventions`
* `external_variables`

Furthermore, per-variable attributes must be attached to the variables to which they refer.
They may not be attached to a group, even if all variables within that group use the same attribute and value.

If attributes are present within groups without being attached to a variable, these attributes apply to the group where they are defined, and to that group's descendants, but not to ancestor or sibling groups.
If a group attribute is defined in a parent group, and one of the child group redefines the same attribute, the definition within the child group applies for the child and all of its descendants.


[[aggregation-variables, Section 2.8, "Aggregation Variables"]]
=== Aggregation Variables

An __aggregation variable__ is a variable which has been formed by combining (i.e. aggregating) multiple __fragments__ that are generally stored in __fragment datasets__ that are external to the file containing the aggregation variable, i.e. the __aggregation file__.
A fragment contains data with sufficient metadata for it to be correctly interpreted in the context of the aggregation.
The aggregation variable does not contain any actual data, instead it contains instructions on how to create its __aggregated data__ in memory as an aggregation of the data from each fragment.
The aggregated data is identical to that which would be stored in the file if the variable were encoded in usual (i.e. non-aggregated) manner.

Aggregation provides the utility of being able to view, as a single entity, a dataset that has been partitioned across multiple other datasets, whilst  taking up very little extra space on disk (since the aggregation file contains no copies of the data in the fragments).
Fragment datasets may be CF-compliant or have any other format, thereby allowing an aggregation variable to act as a CF-compliant view of non-CF datasets.
Aggregations can facilitate data analysis, by avoiding the computational expense of deriving the aggregation at the time of analysis; archive curation, by acting as a metadata-rich archive index; and the post-processing of model simulation outputs, by spanning multiple files written at run time that
together constitute a more cohesive and useful simulation product.

An aggregation variable must be a scalar (i.e. it has no dimensions).
It acts as a container for all of the usual attributes that describe a variable, with the addition of two special attributes: one that defines its _aggregated dimensions_, (i.e. the dimensions of the aggregated data, which in turn define the aggregated data shape); and one that provides the instructions on how the aggregated data is to be created.
The data type of the aggregation variable indicates the data type of the aggregated data, and the value of the aggregation variable's single element can take any value.

Aggregation variables may be used as any kind of variable (data variable, coordinate variable, cell measures variable, etc.), but it is recommended that container variables whose data are immaterial (such as grid mapping variables) not be encoded as aggregation variables.

Any rules that apply to a variable in the CF conventions apply in exactly the same way to an aggregation variable in the same role; and any reference to the dimensions or data of a variable applies to the aggregated dimensions or aggregated data, respectively, of an aggregation variable.
For instance:

* The dimension of a coordinate variable of an aggregation data variable is included as one of the aggregated dimensions of the aggregation data variable.

* The name of an aggregation coordinate variable (which is a scalar) is the same as the name of its single aggregated dimension (identified by its **`aggregated_dimensions`** attribute), just as the name of a coordinate variable (which is one-dimensional) is the same as the name of its single
dimension.

The details of how to encode and decode aggregation variables are given in this section, with extra examples provided in <<appendix-aggregation-examples>>.


[[aggregated-dimensions-and-data, Section 2.8.1, "Aggregated Dimensions and Data"]]
==== Aggregated Dimensions and Data

If a variable has an **`aggregated_dimensions`** attribute, then it must be an aggregation variable.
This attribute records the names of the aggregated dimensions as a blank-separated list, in the order of the dimensions of the aggregated data.
If the aggregated data is scalar then there are no aggregated dimensions and the **`aggregated_dimensions`** attribute must be an empty string.
Any aggregated dimensions must exist as dimensions in the aggregation file.

The aggregated dimensions are partitioned by the fragments (in their canonical forms, see <<fragment-interpretation>>), and this partitioning is consistent across all of the fragments, i.e. any two fragments either span the same part of a given aggregated dimension, or else do not overlap along that same dimension.
In addition, each fragment data value provides exactly one aggregated data value, and each aggregated data value comes from exactly one fragment.
With these constraints, the fragments can be organised into a fully-populated orthogonal multidimensionsal __array of fragments__, for which the size of each dimension is equal to the number of fragments that span its corresponding aggregated dimension.

The aggregated data is formed by combining the fragments in the same relative positions as they appear in the array of fragments, and with no gaps or overlaps between neighbouring fragments.

[[example-array-of-fragments]]
[caption="Example 2.2. "]
.Schematic representation of an array of fragments for aggregated data
====
*Array of fragments*
[cols="a,a"]
|===============
| *Position `[0, 0, 0]`*

Fragment dataset location: `file_A.nc` +
Fragment data shape: `(17, 90, 180)` +
`17` vertical levels  +
`[90, 0]` degrees north  +
`[0, 180]` degrees east | *Position `[0, 0, 1]`*

Fragment dataset location: `file_B.nc` +
Fragment data shape: `(17, 90, 180)` +
`17` vertical levels +
`[90, 0]` degrees north +
`[180, 360]` degrees east

| *Position `[0, 1, 0]`*

Fragment dataset location: `file_C.nc` +
Fragment data shape: `(17, 45, 180)` +
`17` vertical levels +
`[0, -45]` degrees north +
`[0, 180]` degrees east | *Position `[0, 1, 1]`*

Fragment dataset location: `file_D.nc` +
Fragment data shape: `(17, 45, 180)` +
`17` vertical levels +
`[0, -45]` degrees north +
`[180, 360]` degrees east

| *Position `[0, 2, 0]`*

Fragment dataset location: `file_E.nc` +
Fragment data shape: `(17, 45, 180)` +
`17` vertical levels +
`[-45, -90]` degrees north +
`[0, 180]` degrees east | *Position `[0, 2, 1]`*

Fragment dataset location: `file_F.nc` +
Fragment data shape: `(17, 45, 180)` +
`17` vertical levels +
`[-45, -90]` degrees north +
`[180, 360]` degrees east
|===============
The fragments, stored in six fragment datasets, are arranged in a three-dimensional array of fragments with shape `(1, 3, 2)`.
Each fragment spans the entirety of the Z dimension, but only a part of the Y-X plane, which has 1 degree resolution.
The fragments combine to create three-dimensional aggregated data that have global Z-Y-X coverage, with shape `(17, 180, 360)`.
The Z aggregated dimension is spanned by one fragment, the Y aggregated dimension is spanned by three fragments, and the X aggregated dimension is spanned by two fragments.
Note that, since this example is a schematic representation, the C or Fortran order of the dimensions is of no consequence.
See the <<example-aggregation-variable>> example for an encoding of the aggregated data defined by these fragments.
====

The array of fragments must be defined by an aggregation variable's **`aggregated_data`** attribute.
This attribute must take  a string value comprising blank-separated elements of the form "__feature: variable__", where __feature__ is a case-sensitive keyword that specifies a feature of the array of fragments, and __variable__ is a variable in the aggregation file that provides values for that feature.
The order of elements in the **`aggregated_data`** attribute is not significant.

The feature keywords must comprise either `map`, `location`, and `identifier`, or else `map` and `unique_value`.
No other combination of feature keywords is allowed.
The variables that correspond to these features are defined as follows:

// Turn off section numbering for a bit
:numbered!:

===== map

The integer-valued `map` variable maps each fragment (in its canonical form, see <<fragment-interpretation>>) to a part of the aggregated data.
The `map` variable data provides the sizes of the fragments along each of the aggregated dimensions.
The `map` variable is two-dimensional: the rows (i.e. the slowest-varying dimension, and the first dimension in CDL order) correspond to the aggregated dimensions in the same order; and the columns correspond to the fragments along the aggregated dimensions.
Since the aggregated dimensions can be spanned by differing numbers of fragments, the rows of the `map` variable are padded with missing values to create a rectangular array.
The part of each aggregated dimension that is occupied by a given fragment is defined by that fragment's size along that dimension, offset by the sum of the fragment sizes that precede it.

For instance, in the <<example-array-of-fragments>> example, the corresponding `map` variable has 3 rows (one for each of the Z, Y, and X aggregated dimensions), and 3 columns (to allow space for the largest number of fragments along any of the aggregated dimensions).
Each of these rows contains the sizes of the fragments along that dimension, padded with missing values (denoted by `_`) to create the rectangular array:

```
 17   _   _
 90  45  45
180 180   _
```
It follows that the shape of the fragment (in its canonical form, see <<fragment-interpretation>>) at position `[0, 1, 1]` of the array of fragments is `(17, 45, 180)`; and this fragment occupies zero-based indices 0 to 16 of the Z aggregated dimension, 90 to 134 of the Y aggregated dimension, and 180 to 359 of the X aggregated dimension.

In the special case that aggregated data is scalar, the `map` variable must also be scalar and contain the value `1`.
See <<example-L.7>>.

===== location

The string-valued `location` variable defines the locations (i.e. file names) of fragment datasets. 
In general, its dimensions are those of the array of fragments; and its data provide a location for each fragment.
A fragment dataset is located with a Uniform Resource Identifier (URI) <<URI>> that must be either an __absolute URI__ (a URI that begins with a scheme component followed by a `:` character, such as `\file://data/file.nc`, `\https://remote.host/data/file.nc`, `s3://remote.host/data/file.nc`, or `locally_meaningful_protocol://UID`), or else a __relative-path URI reference__ (a URI that is not an absolute URI and which does not begin with a `/` or `#` character, such as `file.nc`, `../file.nc`, or `data/file.nc`).
A relative-path URI reference is taken as being relative to the location of the aggregation file.
If the aggregation file is moved to another location, then a fragment dataset identified by an absolute URI will still be accessible, whereas a fragment dataset identified by a relative-path URI reference will also need be moved to preserve the relative reference.
Not all fragment dataset locations need be of the same URI type.
See <<example-L.1>> and <<example-L.2>>.

The `location` variable may have an extra trailing dimension that allows multiple versions of fragments to be specified.
Each version contains equivalent information, so that any version that exists can be selected for use in the aggregated data.
This could be useful when it is known that a fragment could be stored in various locations, but it is not known which of them might exist at any given time.
For instance, when remotely stored and locally cached versions of the same fragment have been defined, an application program could choose to only retrieve the remote version if the local version does not exist.
Every fragment must have at least one location, but not all fragments need to have the same number of versions.
Where fragments have fewer versions than others, the extra trailing dimension are padded with missing values.
See <<example-L.2>>.

A fragment dataset location may be defined with any number of string substitutions, each of which is provided by the `location` variable's **`substitutions`** attribute.
The **`substitutions`** attribute takes a string value comprising blank-separated elements of the form "__substitution: replacement__", where __substitution__ is a case-sensitive keyword that defines part of a `location` variable value which is to be replaced by __replacement__ in order to find the actual fragment dataset location.
A `location` variable value may include any subset of zero or more of the substitution keywords.
After replacements have been made, the fragment dataset location must be an absolute URI or a relative-path URI reference.
The substitution keyword must have the form `${\*}`, where `*` represents any number of any characters.
For instance, the fragment dataset location `\https://remote.host/data/file.nc` could be stored as `$\{path}file.nc`, in conjunction with `substitutions="$\{path}: \https://remote.host/data/"`.
The order of elements in the **`substitutions`** attribute is not significant, and the substitutions for a given fragment must be such that applying them in any order will result in the same fragment dataset location.
The use of substitutions can save space in the aggregation file; and in the event that the fragment locations need to be updated after the aggregation file has been created, it could be possible to achieve this by modifying the **`substitutions`** attribute rather than by changing the actual `location` variable values.
See <<example-L.3>>.

===== identifier

The `identifier` variable defines how to extract each fragment from within its fragment dataset.
In general, the dimensions of the `identifier` variable are the same, and in the same order, as those of the `location` variable, and its data contain an identifier corresponding to each fragment location.
If the identifiers are the same for all fragments then the `identifier` variable may be a scalar whose single data value is the identifier common to all fragments.
The identifier for a netCDF fragment dataset is the string-valued variable name of the fragment, which does not need to be the same as the name of the aggregation variable.
See <<example-L.1>> and <<example-L.5>>.

===== unique_value

When the data values within each fragment are all identical, the `unique_value` variable allows these unique values to be explicitly stored in the aggregation file, rather than by reference to external fragment datasets via the `location` and `identifier` variables.
The `unique_value` variable dimensions are those of the array of fragments, and the data provide the unique value for each fragment.
The fragment implied by a unique value has dimensions corresponding to the aggregated dimensions, and the fragment shape is defined by the `map` variable.
When a fragment contains wholly missing data, its unique value is specified as any missing value defined by the aggregation variable.
See <<example-L.6>>, which uses an ancillary aggregation variable to make global attributes from the fragment datasets available in the aggregation file.

// Turn section numbering back on
:numbered:


[[example-aggregation-variable]]
[caption="Example 2.3. "]
.Aggregation variable
====
----
dimensions:
  level = 17 ;
  latitude = 180 ;
  longitude = 360 ;
  // Array of fragments dimensions
  f_level = 1 ;
  f_latitude = 3 ;
  f_longitude = 2 ;
  // Map variable dimensions
  j = 3 ;        // Number of aggregated dimensions
  i = 3 ;        // Largest number of fragments along any aggregated dimension

variables:
  // Data aggregation variable
  double temperature ;
    temperature:standard_name = "air_temperature" ;
    temperature:units = "K" ;
    temperature:cell_methods = "time: mean" ;
    temperature:aggregated_dimensions = "level latitude longitude" ;
    temperature:aggregated_data = "location: fragment_location
                                   identifier: fragment_identifier
                                   map: fragment_map" ;
  // Coordinate variables
  double level(level) ;
    level:standard_name = "air_pressure" ;
    level:units = "hPa" ;
  double latitude(latitude) ;
    latitude:standard_name = "latitude" ;
    latitude:units = "degrees_north" ;
  double longitude(longitude) ;
    longitude:standard_name = "longitude" ;
    longitude:units = "degrees_east" ;
  // Array of fragments variables
  int fragment_map(j, i) ;
  string fragment_location(f_level, f_latitude, f_longitude) ;
  string fragment_identifier ;

data:
  temperature = _ ;
  level = ... ;
  latitude = ... ;
  longitude = ... ;
  fragment_map = 17, _, _,
                 90, 45, 45,
                 180, 180, _ ;
  fragment_location = "file_A.nc", "file_B.nc",
                      "file_C.nc", "file_D.nc",
                      "file_E.nc", "file_F.nc" ;
  fragment_identifier = "tmp" ;
----
An encoding for the aggregated data defined by the fragments described in the <<example-array-of-fragments>> example.
The `temperature` data variable is an aggregation of six fragments.
The amounts of non-missing values in each row of the `fragment_map` variable indicate that the `level` aggregated dimension is spanned by one fragment, the `latitude` aggregated dimension is spanned by three fragments, and the `longitude` aggregated dimension is spanned by two fragments; and that the shape of the array of fragments is therefore `(1, 3, 2)`.
Note that the row sums of the `fragment_map` variable are `17`, `180`, and `360`, which equal the sizes of the `level`, `latitude`, and `longitude` aggregated dimensions, respectively.

The data for the `level`, `latitude` and  `longitude` variables are omitted for clarity.
====

[[fragment-interpretation, Section 2.8.2 "Fragment Interpretation"]]
==== Fragment Interpretation

Fragments can be encoded in many different but equivalent ways, so we define a __canonical form__ of a fragment's data that provides a view of the fragment for which all data values are consistent with those from other fragments, as well as with the attributes of the aggregation variable.
When constructing the aggregated data, it is assumed that each fragment's data has been transformed to its canonical form.
The canonical form of a fragment's data is such that:

1. The fragment's data has the same number of dimensions, and in the same order, as the aggregated data.

2. The fragment's data have the same units as the aggregation variable.

3. The fragment's data have the same data type as the aggregation variable.

4. Missing values in the fragment's data the same as those defined by the aggregation variable.

5. The fragment's data are unpacked (as described in <<packed-data>>).

A fragment dataset can deviate from any of these requirements, provided that it is possible to convert the fragment to its canonical form without changing the meaning of the data.
For instance, if the aggregation variable had units of `kg m-2`, then the fragment data could have any of the equivalent units `kg m-2`, `g cm-2`, etc., but it would be an error if the fragment had any other unit for which its values can not be converted to `kg m-2` (such `K`).

The conversion of the fragment's data to its canonical form is carried out by the application program which is creating the aggregated data in memory. The application program can ignore any metadata and variables in a fragment dataset that are not needed for the conversion to the canonical form.
When transforming a fragment's data to its canonical form, note that:

* A fragment can have fewer dimensions than the aggregated data provided that the missing dimensions have size 1 (e.g. as could be the case when aggregating two-dimensional fragments into three-dimensional aggregated data); but a fragment can not have more dimensions than the aggregated data.

* It is the responsibility of the creator of the aggregation file to ensure that all valid values in a fragment's data are different from any of the missing values defined by the aggregation variable.

* The aggregated data is identical to the data that would be stored within a dataset that contained the equivalent non-aggregation variable.
Therefore, if the aggregation variable indicates that its data are packed or compressed (such as by techniques described in <<reduction-of-dataset-size>>) then the aggregated data, after its creation, is subject to the aggregation variable's unpacking or decompression procedures.
